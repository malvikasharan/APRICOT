// Generated by CoffeeScript 1.9.2
var CanvasCoordsCache, CanvasSeqDrawer, CharCache, SelectionClass, _, boneView, jbone, mouse;

boneView = require("backbone-childs");

mouse = require("mouse-pos");

_ = require("underscore");

jbone = require("jbone");

CharCache = require("./CanvasCharCache");

SelectionClass = require("./CanvasSelection");

CanvasSeqDrawer = require("./CanvasSeqDrawer");

CanvasCoordsCache = require("./CanvasCoordsCache");

module.exports = boneView.extend({
  tagName: "canvas",
  initialize: function(data) {
    this.g = data.g;
    this.listenTo(this.g.zoomer, "change:_alignmentScrollLeft change:_alignmentScrollTop", function(model, value, options) {
      if (((options != null ? options.origin : void 0) == null) || options.origin !== "canvasseq") {
        return this.render();
      }
    });
    this.listenTo(this.g.columns, "change:hidden", this.render);
    this.listenTo(this.g.zoomer, "change:alignmentWidth change:alignmentHeight", this.render);
    this.listenTo(this.g.colorscheme, "change", this.render);
    this.listenTo(this.g.selcol, "reset add", this.render);
    this.listenTo(this.model, "reset add", this.render);
    this.el.style.display = "inline-block";
    this.el.style.overflowX = "hidden";
    this.el.style.overflowY = "hidden";
    this.el.className = "biojs_msa_seqblock";
    this.ctx = this.el.getContext('2d');
    this.cache = new CharCache(this.g);
    this.coordsCache = new CanvasCoordsCache(this.g, this.model);
    this.listenTo(this.g.zoomer, "change:residueFont", function() {
      this.cache = new CharCache(this.g);
      return this.render();
    });
    this.sel = new SelectionClass(this.g, this.ctx);
    this._setColor();
    this.throttleTime = 0;
    this.throttleCounts = 0;
    if (document.documentElement.style.webkitAppearance != null) {
      this.throttledDraw = function() {
        var start, tTime;
        start = +new Date();
        this.draw();
        this.throttleTime += +new Date() - start;
        this.throttleCounts++;
        if (this.throttleCounts > 15) {
          tTime = Math.ceil(this.throttleTime / this.throttleCounts);
          console.log("avgDrawTime/WebKit", tTime);
          return this.throttledDraw = this.draw;
        }
      };
    } else {
      this.throttledDraw = _.throttle(this.throttledDraw, 30);
    }
    return this.manageEvents();
  },
  throttledDraw: function() {
    var start, tTime;
    start = +new Date();
    this.draw();
    this.throttleTime += +new Date() - start;
    this.throttleCounts++;
    if (this.throttleCounts > 15) {
      tTime = Math.ceil(this.throttleTime / this.throttleCounts);
      console.log("avgDrawTime", tTime);
      tTime *= 1.2;
      tTime = Math.max(20, tTime);
      return this.throttledDraw = _.throttle(this.draw, tTime);
    }
  },
  manageEvents: function() {
    var events;
    events = {};
    events.mousedown = "_onmousedown";
    events.touchstart = "_ontouchstart";
    if (this.g.config.get("registerMouseClicks")) {
      events.dblclick = "_onclick";
    }
    if (this.g.config.get("registerMouseHover")) {
      events.mousein = "_onmousein";
      events.mouseout = "_onmouseout";
    }
    events.mousewheel = "_onmousewheel";
    events.DOMMouseScroll = "_onmousewheel";
    this.delegateEvents(events);
    this.listenTo(this.g.config, "change:registerMouseHover", this.manageEvents);
    this.listenTo(this.g.config, "change:registerMouseClick", this.manageEvents);
    return this.dragStart = [];
  },
  _setColor: function() {
    return this.color = this.g.colorscheme.getSelectedScheme();
  },
  draw: function() {
    this.el.width = this.el.width;
    if ((this.seqDrawer != null) && this.model.length > 0) {
      this.seqDrawer.drawLetters();
      this.seqDrawer.drawRows(this.sel._appendSelection, this.sel);
      return this.seqDrawer.drawRows(this.drawFeatures, this);
    }
  },
  drawFeatures: function(data) {
    var ctx, rectHeight, rectWidth;
    rectWidth = this.g.zoomer.get("columnWidth");
    rectHeight = this.g.zoomer.get("rowHeight");
    if (data.model.attributes.height > 1) {
      ctx = this.ctx;
      data.model.attributes.features.each(function(feature) {
        var len, y;
        ctx.fillStyle = feature.attributes.fillColor || "red";
        len = feature.attributes.xEnd - feature.attributes.xStart + 1;
        y = (feature.attributes.row + 1) * rectHeight;
        return ctx.fillRect(feature.attributes.xStart * rectWidth + data.xZero, y + data.yZero, rectWidth * len, rectHeight);
      });
      ctx.fillStyle = "black";
      ctx.font = this.g.zoomer.get("residueFont") + "px mono";
      ctx.textBaseline = 'middle';
      ctx.textAlign = "center";
      return data.model.attributes.features.each(function(feature) {
        var len, y;
        len = feature.attributes.xEnd - feature.attributes.xStart + 1;
        y = (feature.attributes.row + 1) * rectHeight;
        return ctx.fillText(feature.attributes.text, data.xZero + feature.attributes.xStart * rectWidth + (len / 2) * rectWidth, data.yZero + rectHeight * 0.5 + y);
      });
    }
  },
  render: function() {
    this.el.setAttribute('height', this.g.zoomer.get("alignmentHeight") + "px");
    this.el.setAttribute('width', this.g.zoomer.getAlignmentWidth() + "px");
    this.g.zoomer._checkScrolling(this._checkScrolling([this.g.zoomer.get('_alignmentScrollLeft'), this.g.zoomer.get('_alignmentScrollTop')]), {
      header: "canvasseq"
    });
    this._setColor();
    this.seqDrawer = new CanvasSeqDrawer(this.g, this.ctx, this.model, {
      width: this.el.width,
      height: this.el.height,
      color: this.color,
      cache: this.cache
    });
    this.throttledDraw();
    return this;
  },
  _onmousemove: function(e, reversed) {
    var dragEnd, i, j, k, l, relDist, relEnd, scaleFactor, scrollCorrected;
    if (this.dragStart.length === 0) {
      return;
    }
    dragEnd = mouse.abs(e);
    relEnd = [dragEnd[0] - this.dragStart[0], dragEnd[1] - this.dragStart[1]];
    scaleFactor = this.g.zoomer.get("canvasEventScale");
    if (reversed) {
      scaleFactor = 3;
    }
    for (i = j = 0; j <= 1; i = j += 1) {
      relEnd[i] = relEnd[i] * scaleFactor;
    }
    relDist = [this.dragStartScroll[0] - relEnd[0], this.dragStartScroll[1] - relEnd[1]];
    for (i = k = 0; k <= 1; i = k += 1) {
      relDist[i] = Math.round(relDist[i]);
    }
    scrollCorrected = this._checkScrolling(relDist);
    this.g.zoomer._checkScrolling(scrollCorrected, {
      origin: "canvasseq"
    });
    for (i = l = 0; l <= 1; i = l += 1) {
      if (scrollCorrected[i] !== relDist[i]) {
        if (scrollCorrected[i] === 0) {
          this.dragStart[i] = dragEnd[i];
          this.dragStartScroll[i] = 0;
        } else {
          this.dragStart[i] = dragEnd[i] - scrollCorrected[i];
        }
      }
    }
    this.throttledDraw();
    if (e.preventDefault != null) {
      e.preventDefault();
      return e.stopPropagation();
    }
  },
  _ontouchmove: function(e) {
    this._onmousemove(e.changedTouches[0], true);
    e.preventDefault();
    return e.stopPropagation();
  },
  _onmousedown: function(e) {
    this.dragStart = mouse.abs(e);
    this.dragStartScroll = [this.g.zoomer.get('_alignmentScrollLeft'), this.g.zoomer.get('_alignmentScrollTop')];
    jbone(document.body).on('mousemove.overmove', (function(_this) {
      return function(e) {
        return _this._onmousemove(e);
      };
    })(this));
    jbone(document.body).on('mouseup.overup', (function(_this) {
      return function() {
        return _this._cleanup();
      };
    })(this));
    return e.preventDefault();
  },
  _ontouchstart: function(e) {
    this.dragStart = mouse.abs(e.changedTouches[0]);
    this.dragStartScroll = [this.g.zoomer.get('_alignmentScrollLeft'), this.g.zoomer.get('_alignmentScrollTop')];
    jbone(document.body).on('touchmove.overtmove', (function(_this) {
      return function(e) {
        return _this._ontouchmove(e);
      };
    })(this));
    return jbone(document.body).on('touchend.overtend touchleave.overtleave touchcancel.overtcanel', (function(_this) {
      return function(e) {
        return _this._touchCleanup(e);
      };
    })(this));
  },
  _onmousewinout: function(e) {
    if (e.toElement === document.body.parentNode) {
      return this._cleanup();
    }
  },
  _cleanup: function() {
    this.dragStart = [];
    jbone(document.body).off('.overmove');
    jbone(document.body).off('.overup');
    return jbone(document.body).off('.overout');
  },
  _touchCleanup: function(e) {
    if (e.changedTouches.length > 0) {
      this._onmousemove(e.changedTouches[0], true);
    }
    this.dragStart = [];
    jbone(document.body).off('.overtmove');
    jbone(document.body).off('.overtend');
    jbone(document.body).off('.overtleave');
    return jbone(document.body).off('.overtcancel');
  },
  _onmousewheel: function(e) {
    var delta;
    delta = mouse.wheelDelta(e);
    this.g.zoomer.set('_alignmentScrollLeft', this.g.zoomer.get('_alignmentScrollLeft') + delta[0]);
    this.g.zoomer.set('_alignmentScrollTop', this.g.zoomer.get('_alignmentScrollTop') + delta[1]);
    return e.preventDefault();
  },
  _onclick: function(e) {
    var res;
    res = this._getClickPos(e);
    if (res != null) {
      if (res.feature != null) {
        this.g.trigger("feature:click", res);
      } else {
        this.g.trigger("residue:click", res);
      }
    }
    return this.throttledDraw();
  },
  _onmousein: function(e) {
    var res;
    res = this._getClickPos(e);
    if (res != null) {
      if (res.feature != null) {
        this.g.trigger("feature:mousein", res);
      } else {
        this.g.trigger("residue:mousein", res);
      }
    }
    return this.throttledDraw();
  },
  _onmouseout: function(e) {
    var res;
    res = this._getClickPos(e);
    if (res != null) {
      if (res.feature != null) {
        this.g.trigger("feature:mouseout", res);
      } else {
        this.g.trigger("residue:mouseout", res);
      }
    }
    return this.throttledDraw();
  },
  _getClickPos: function(e) {
    var coords, feature, features, ref, rowNumber, seqId, x, y;
    coords = mouse.rel(e);
    coords[0] += this.g.zoomer.get("_alignmentScrollLeft");
    x = Math.floor(coords[0] / this.g.zoomer.get("columnWidth"));
    ref = this.seqDrawer._getSeqForYClick(coords[1]), y = ref[0], rowNumber = ref[1];
    x += this.g.columns.calcHiddenColumns(x);
    y += this.model.calcHiddenSeqs(y);
    x = Math.max(0, x);
    y = Math.max(0, y);
    seqId = this.model.at(y).get("id");
    if (rowNumber > 0) {
      features = this.model.at(y).get("features").getFeatureOnRow(rowNumber - 1, x);
      if (features.length !== 0) {
        feature = features[0];
        console.log(features[0].attributes);
        return {
          seqId: seqId,
          feature: feature,
          rowPos: x,
          evt: e
        };
      }
    } else {
      return {
        seqId: seqId,
        rowPos: x,
        evt: e
      };
    }
  },
  _checkScrolling: function(scrollObj) {
    var i, j, max;
    max = [this.coordsCache.maxScrollWidth, this.coordsCache.maxScrollHeight];
    for (i = j = 0; j <= 1; i = j += 1) {
      if (scrollObj[i] > max[i]) {
        scrollObj[i] = max[i];
      }
      if (scrollObj[i] < 0) {
        scrollObj[i] = 0;
      }
    }
    return scrollObj;
  }
});
